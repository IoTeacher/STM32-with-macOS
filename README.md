Using GCC and Makefiles on macOS to build STM32CubeMX projects
================================================================

As of v4.21.0, [STM32CubeMX] is now capable of generating Makefiles that can be used to build projects using the [GNU ARM Embedded Toolchain]. Makefiles allow you to be independent of IDEs and use you favorite text editor. For some people, IDEs are slow and take up a lot of resources. With Makefile, building your project is as simple as typing *make* in your Terminal be you in Linux, Mac, or Windows. No more restrictions.

Although this tutorial has been written with macOS in mind, similar steps can be applied to linux or Windows machines.


0 - Installing the toolchain
------------------------
### Requirements:
- [STM32CubeMX] for project template generation
- [STM32CubeProgrammer] for easy programming of STM32 products
- A hardware development board (*e.g.* a [NUCLEO-L476RG] board)
- macOS Command Line Tools (CLT)
- [Homebrew] package manager (recommended to install openOCD and arm-none-eabi)
- [GNU ARM Embedded Toolchain] (arm-none-eabi) for the compiler and other tools
- [OpenOCD] (>= 0.10.0) or [texane/stlink] for programming and running a gdb server


1. Install Xcode Command Line Tools:
```Shell
$ xcode-select --install
```
After the Command Line Tools were successfully installed, the remaining toolchain requirements can be installed using Homebrew.

2. Install Homebrew, follow instructions available on [brew.sh][Homebrew]
3. Install GCC ARM Embedded Toolchain:
```Shell
$ brew install gcc-arm-embedded
$ arm-none-eabi-gcc --version
arm-none-eabi-gcc (GNU Tools for Arm Embedded Processors 7-2017-q4-major) 7.2.1 20170904 (release) [ARM/embedded-7-branch revision 255204]
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

4. Install openOCD:
```Shell
$ brew install openocd
$ openOCD --version
Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
    http://openocd.org/doc/doxygen/bugs.html
```

5. Install open source [texane/stlink]:
```Shell
$ brew install stlink
$ st-info --version
v1.4.0
```

GL NOTE: see https://github.com/glegrain/WarkaWater/ README.md for out-of-date instructions


1 - Create a Project using CubeMX
-------------------------------
See Getting started from [st.com](http://www.st.com/resource/en/user_manual/dm00104712.pdf). In the Project Settings, under *Toolchain / IDE*, select *Makefile*. 

![Project Settings](images/Project_Settings.png)

Here, you can use the example "blinky" project:
TODO:
```
$ git clone http://github.com/legraing/STM32L476-Blinky
$ cd ......
```

2 - Configuring your Makefile
-----------------------------
Unfortunately, Makefiles generated by CubeMX do not work *out-of-the-box*, you need to edit the file and set your compiler path. Luckily, this step only has to be done once. Later on, if you want to add source, header files or simply change your compiler options, refer to the [Editing your Makefile] section for more details.

1. Locate the ARM Embedded GCC compiler binary location
```Shell
$ which arm-none-eabi-gcc
/usr/local/bin/arm-none-eabi-gcc
```

2. Set the `BINPATH` variable to the location of your compiler returned above:
```Makefile
#######################################
# binaries
#######################################
BINPATH = /usr/local/bin
PREFIX = arm-none-eabi-
```
**Pro Tip**: To make the Makefile more portable between different users and environment, you can remove the `BINPATH` variable and edit the `CC`, `AS`, .. variable to point to the compiler located in your environment path.

3 - Building your project
-------------------------
Use the `make` command to invoke the Makefile to compile your project
```Shell
$ make
```
**Pro Tip**: for faster build, make can be invoked using parallel build:
```Shell
$ make -j 4
```

If all goes well, you should see something like this
```
/usr/local/bin/arm-none-eabi-size build/STM32L0-BlinkyCube.elf
   text    data     bss     dec     hex filename
   4128      12    1572    5712    1650 build/STM32L0-BlinkyCube.elf
/usr/local/bin/arm-none-eabi-objcopy -O ihex build/STM32L0-BlinkyCube.elf build/STM32L0-BlinkyCube.hex
/usr/local/bin/arm-none-eabi-objcopy -O binary -S build/STM32L0-BlinkyCube.elf build/STM32L0-BlinkyCube.bin 
```

**Pro Tip**: The Makefile template generated by CubeMX comes with a predefined rule called `clean` to delete all generated files during the build process (object files, binaries, ...).
This rule is very useful to for a rebuild all or to cleanup the project directory before packaging your project directory for archiving.

4 - Programming the board
-------------------------

### Using STM32CubeProg:


### Using openOCD:
TODO: Check if path is still valid when openOCD was installed using Homebrew
```Shell
$ ls /Applications/GNU ARM Eclipse/OpenOCD/0.10.0-201610281609-dev/scripts/board/
$ openocd -f scripts/board/stm32l0discovery.cfg
$ openocd -f interface/stlink-v2-1.cfg -f target/stm32l4x.cfg
```

### Using texane stlink:
If all you want to do is program the board, then run:
```Shell
$ st-flash write ./build/*.bin 0x08000000
```
Note: `*.hex` does not appear to work

Otherwise, to program and debug run the gdb server with:
```Shell
$ st-util 
```

5 - Debugging
-------------
(Connecting gdb)

Here is my `.gdbinit`:
```GDB
# Connect to texane stlink gdb server
target extended-remote :4242
# Or, connect to openOCD instead
# target remote localhost:3333
# monitor reset init
# monitor halt

# Uncomment to enable semihosting
# monitor arm semihosting enable

# If binary was not provided during gdb launch, load it:
# alternatively, symbols can be loaded using:
# symbol-file  “./build/<BinaryName>.elf”
# or
# symbol-file
# load “./build/<BinaryName>.elf”
thbreak main
monitor reset halt
monitor halt
# Run to main (first breakpoint)
continue
```

### Launch gdb:
gdb will use `.gdbinit` file
```
$ arm-none-eabi-gdb
```

### Program stepping/execution:
https://sourceware.org/gdb/onlinedocs/gdb/Continuing-and-Stepping.html
Step over (step to next line of C code without going into functions):
```GDB
(gdb) next
```

Step into (step to next line of C, goes into functions):
```GDB
(gdb) step
```
Note: Use `stepi` for assembly instruction stepping.

Return from a function:
```GDB
(gdb) finish
```

Run until next breakpoint:
```GDB
(gdb) continue
```


### Setting a breakpoint:
https://sourceware.org/gdb/onlinedocs/gdb/Breakpoints.html#Breakpoints
http://www.unknownroad.com/rtfm/gdbtut/gdbbreak.html
From there, you can add breakpoints using any of the following methods in the gdb command:

Break on line number and run until breakpoint:
```GDB
(gdb) break main.c:81
(gdb) continue
```

TODO: Add gdb output

Break on function:
```GDB
(gdb) break SystemClock_Config
(gdb) continue
```

### Inspecting variables and memory:
```GDB
(gdb) p uwTick
```

```GDB
(gdb) x/1028x 0x20000000
```

**Pro Tip**: Inspecting registers:
https://community.st.com/message/178766-reading-io-register-values-with-command-line-gdb
Include additional debug information, such as all the macro definitions that can be used to inspect I/O registers:
1. Edit you Makefile to add the `-g3` option to the  `CFLAGS` variable.
2. In gdb, type:
```GDB
(gdb) p /x *GPIOB
(gdb) p /x TIM3->CCMR1
```

Other
-----

Advanced GDB:
Using gdb-dashboard (do not use tui mode):
```Shell
$ arm-none-eabi-gdb-py 
```

Where to go from here:

Editing your Makefile
---------------------
### Adding source files:
Any additional source file (`*.c` or `*.s`) that needs to be compiled should be added to the `C_SOURCES` or `ASM_SOURCES` variables inside the Makefile. 
```Makefile
######################################
# source
######################################
# C sources
C_SOURCES = \
./Src/main.c \
./Src/new_file.c \
./Src/stm32l4xx_it.c \
./Src/syscalls.c \
./Src/system_stm32l4xx.c \

# ASM sources
ASM_SOURCES =  \
./startup_stm32l476xx.s
```
**Pro Tip**: I prefixed my paths with `./` to help vim trigger file path completion.

### Adding Includes:

```Makefile
C_INCLUDES:
```
**Pro Tip**: if the compiler complains about a missing header file for example:
```
./Src/usbd_conf.c:53:10: fatal error: usbd_msc.h: No such file or directory
 #include "usbd_msc.h"
          ^~~~~~~~~~~~
```
use `find . -name "usbd_msc.h"` to get the path and add it to Makefile

### Adding Preprocessor defines:
https://gcc.gnu.org/onlinedocs/gcc-7.3.0/gcc/Preprocessor-Options.html
```Makefile
# C defines
C_DEFS =  \
-DUSE_HAL_DRIVER \
-DSTM32L476xx \
-D__DEBUG__
```


### Changing optimization options:
https://gcc.gnu.org/onlinedocs/gcc-7.3.0/gcc/Optimize-Options.html

Serial console:
---------------
Retargetting the C printf function can be very usefull for debugging or 
### Using UART:
On embedded devices, 
messages 
Note: With GCC, make sure to add `syscalls.c`

See [my GitHub gist][uart.c] to retarget printf to UART

#### minicom
```Shell
$ minimum -D /dev/tty.usbmodem413 -b 921600
```

#### screen
```Shell
$ screen /dev/tty.usbmodem413 921600
```

### Using semihosting:
Semihosting is relatively easy to setup but it is one of the slowest methods for printing debug messages. 
Enable semihosting (see example `.gdbinit`)

### Using ITM messages over SWO:
with openOCD, ITM can be configured using the `tpiu` command.
https://mcuoneclipse.com/2016/10/17/tutorial-using-single-wire-output-swo-with-arm-cortex-m-and-eclipse/
http://blog.japaric.io/itm/

Understanding compiler options and flags:
https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html


Debugging tips (Part 2?)
mdw
flash program
flash mass_erase
setting breakpoints
viewing registers and SFRs
  reg
  mdw
semihosting

Linker

Ressources
https://developer.arm.com/open-source/gnu-toolchain/gnu-rm
http://www.bravegnu.org/gnu-eprog/
http://blog.japaric.io/quickstart/#hello-world
https://www.gnu.org/software/make/manual/make.html


Issues:
-------
When creating a brand new project (example NUCLEO-L476RG), C source files under Src/ are defined multiple times. 


Using vim:
Browse tags with ctrl-] and back using ctrl-t
ctags -R .

:cs 
cscope -R .

[STM32CubeMX]:http://www.st.com/en/development-tools/stm32cubemx.html
[GNU ARM Embedded Toolchain]:https://developer.arm.com/open-source/gnu-toolchain/gnu-rm
[STM32CubeProgrammer]:
[Homebrew]:https://brew.sh/
[OpenOCD]:http://openocd.org/
[texane/stlink]:https://github.com/texane/stlink
[NUCLEO-L476RG]:http://www.st.com/en/evaluation-tools/nucleo-l476rg.html

[uart.c]:https://gist.github.com/glegrain/ca92f631e578450a933c67ac3497b4df
